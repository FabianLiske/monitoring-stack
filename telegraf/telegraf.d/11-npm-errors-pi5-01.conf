[[inputs.tail]]
  files               = ["/var/log/npm/all_proxy_error.log"]
  initial_read_offset = "begining"           # einmalig f√ºr Backfill auf "beginning" stellen
  watch_method        = "poll"
  data_format         = "grok"
  name_override       = "npm_error"

  # Feste Tags inline (Routing/Ident)
  tags = { domain = "service", proxy_id = "npm@pi5-01" }

  # Muster + eigene Patterns
  grok_patterns = ['%{NGINX_ERROR_ENRICHED}']
  grok_custom_patterns = """
NGXERRTS %{YEAR:year}/%{MONTHNUM:month}/%{MONTHDAY:day} %{TIME:time}
NGINX_ERROR_ENRICHED %{NGXERRTS:ts} \[%{LOGLEVEL:level}\] %{NUMBER:pid:int}#%{NUMBER:tid:int}: \*%{NUMBER:conn:int} %{DATA:message}(?:, client: %{IPORHOST:client})?(?:, server: %{HOSTNAME:server})?(?:, request: "%{WORD:method} %{DATA:request_uri} HTTP/%{NUMBER:http_version}")?(?:, upstream: "(?:%{URI:upstream}|%{DATA:upstream})")?(?:, host: "%{DATA:host}")?(?:, referrer: "%{DATA:referrer}")?
"""

# level & server zu Tags promoten (kommen als Fields aus Grok)
[[processors.enum]]
  [[processors.enum.tag]]
    field = "level"
    dest  = "level"
  [[processors.enum.tag]]
    field = "server"
    dest  = "server"

# Event-Typ aus message ableiten (z. B. Disk-Pufferung)
[[processors.regex]]
  [[processors.regex.fields]]
    key         = "message"
    pattern     = "buffered to a temporary file"
    replacement = "buffered_tempfile"
    result_key  = "event"

# upstream_host aus upstream-URL ziehen
[[processors.regex]]
  [[processors.regex.fields]]
    key         = "upstream"
    pattern     = "^https?://([^/:]+)"
    replacement = "${1}"
    result_key  = "upstream_host"

# event & upstream_host als Tags verwenden
[[processors.enum]]
  [[processors.enum.tag]]
    field = "event"
    dest  = "event"
  [[processors.enum.tag]]
    field = "upstream_host"
    dest  = "upstream_host"

# Typen festziehen (optional)
[[processors.converter]]
  [processors.converter.fields]
    integer = ["pid","tid","conn"]
    float   = ["http_version"]
